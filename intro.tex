\chapter{Introduction: SMT solvers and interfaces}
\label{sec:motiv}

Satisfiability Modulo Theories (SMT) solvers let programmers specify constraints
over booleans, integers, pure functions and other types, and either come up
with assignments that satisfy these constraints, or, if possible, a proof that
the constraints aren't satisfiable. Over the last few years, SMT solvers using
DPLL(T)~\cite{dpllt:04} and other frameworks have come into their own and can
solve a wide variety of problems using efficient heuristics. Problems they can
attack range from simple puzzles like Sudoku and n-queens, to planning and
scheduling, program analysis~\cite{Gulwani:08}, whitebox fuzz
testing~\cite{Godefroid:08} and bounded model checking~\cite{Armando:09}.

Yet, SMT solvers are only used by a small number of experts. It isn't hard to
see why: the standard way for programs to interact with SMT solvers like
Z3~\cite{z3}, Yices~\cite{yices} and CVC3~\cite{cvc3} is via powerful but
relatively arcane C APIs that require the users to know the particular
solver's internals. For example, \Fref{fig:c-prop} lists a C program that
asks Z3 whether the simple proposition $p \wedge \neg p$ is satisfiable.

\begin{program}
\caption{A C program to ask Z3 whether $p \wedge \neg p$ is satisfiable}
\label{fig:c-prop}
\begin{minted}{c}
Z3_config cfg = Z3_mk_config();
Z3_context ctx = Z3_mk_context(cfg);
Z3_del_config(cfg);
Z3_sort bool_sort = Z3_mk_bool_sort(ctx);

Z3_symbol symbol_p = Z3_mk_int_symbol(ctx, 0);

Z3_ast p = Z3_mk_const(ctx, symbol_p, bool_sort);
Z3_ast not_p = Z3_mk_not(ctx, p);

Z3_ast args[2] = {p, not_p};
Z3_ast conjecture = Z3_mk_and(ctx, 2, args);

Z3_assert_cnstr(ctx, conjecture);

Z3_lbool sat = Z3_check(ctx);

Z3_del_context(ctx);
return sat;
\end{minted}
\end{program}

Simultaneously, most SMT solvers also feature interaction via the standard
input language SMT-LIB~\cite{smtlib2:10}. SMT-LIB is \textit{significantly}
easier to use in isolation. The same program in SMT-LIB would look something
like \Fref{fig:smtlib-prop}.

\begin{program}
\caption{An SMT-LIB program to check whether $p \wedge \neg p$ is satisfiable}
\label{fig:smtlib-prop}
\begin{minted}{scheme}
; Declare a variable we don't know the value of yet
(declare-fun p () Bool)
; Try to find a value satisfying a contradiction
(assert (and p (not p)))
(check-sat)
; Prints "unsat", meaning "unsatisfiable"
\end{minted}
\end{program}

However, the SMT-LIB interfaces are generally hard to use directly from C
programs and often not as full-featured\footnote{Z3, for instance, supports
plugging in external theories via the C API, but not via the textual SMT-LIB
interface.}  or extensible. Importantly, it is difficult to write programs
that \textit{interact} with the solver in some way, for example by adding
assertions based on generated models. This makes it difficult to build new
abstractions to enhance functionality.

To overcome these difficulties, we decided to implement an SMT-LIB-like
interface in a way that allowed for the same power as the C interface while
appearing naturally integrated into a host language. Since SMT-LIB is {\em
s-expression}-based, for the host language a Lisp dialect was a natural
choice. We chose Racket~\cite{racket} for our implementation, \texttt{z3.rkt},
because of its extensive facilities for implementing new languages~\cite
{Tobin-Hochstadt:11}, not just for the interface to the solver, but also for
the resulting tools that the solver would make possible.

Using this system, the program (\Fref{fig:rkt-prop}) becomes almost as brief
as the SMT-LIB version.

\begin{program}
\caption{Using \texttt{z3.rkt} to determine whether $p \wedge \neg p$ is satisfiable}
\label{fig:rkt-prop}
\begin{minted}{scheme}
(smt:with-context
 (smt:new-context)
 (smt:declare-fun p () Bool)
 (smt:assert (and/s p (not/s p)))
 (smt:check-sat))
\end{minted}
\end{program}

\section{Interactive SMT solving: two examples}
\label{sec:interactive}

To demonstrate how the interaction of a language with an SMT solver is useful, we
turn our attention to a pair of classic logical puzzles.

\subsection{Sudoku}

A Sudoku puzzle asks the player to complete a partially pre-filled 9$\times$9
grid with the numbers 1 through 9 such that no row, column, or 3$\times$3 box
has two instances of a number. This is a classic constraint satisfaction
problem, and any constraint solver can handle it with ease.

\Fref{fig:sudoku} lists a Racket program using \texttt{z3.rkt} to solve Sudoku.

\begin{program}
\caption{Racket code using \texttt{z3.rkt} to solve Sudoku}
\label{fig:sudoku}
\begin{minted}{scheme}
(define (solve-sudoku grid)
  (smt:with-context
   (smt:new-context)
   ; Declare a scalar datatype (finite domain type) with 9 entries
   (smt:declare-datatypes ()
     ((Sudoku S1 S2 S3 S4 S5 S6 S7 S8 S9)))
   ; Represent the grid as an array from integers to this type
   (smt:declare-fun sudoku-grid () (Array Int Sudoku))
   ; Assert the standard grid rules (row, column, box)
   (add-sudoku-grid-rules)
   ; Add pre-filled entries
   (add-grid grid)
   (define sat (smt:check-sat))
   ; 'sat means we found a solution, 'unsat means we didn't
   (if (eq? sat 'sat)
       ; Retrieve the values from the model
       (for/list ([x (in-range 0 81)])
         (smt:eval (select/s sudoku-grid x)))
       #f)))
\end{minted}
\end{program}

Here we omit a couple of function definitions: \texttt{add-sudoku-grid-rules}
asserts the standard Sudoku grid rules, and \texttt{add-grid} reads a
partially filled grid in a particular format and creates assertions based on
it. We note that the function \texttt{(select/s arr x)} retrieves the value at
\texttt{x} from the array \texttt{arr}, and that this can be used to add
constraints on the array (for instance, \texttt{(smt:assert (=/s (select/s arr
x) y))}). We also note that if a set of constraints is satisfiable, Z3 can
generate a \textit{model} showing this; values can be extracted out of this
model using the \texttt{smt:eval} command.

However, simply finding a solution isn't enough for a good Sudoku solver: it
must also verify that there aren't any other solutions. The usual way to do
that for a constraint solver is by retrieving a generated model, adding
assertions such that this model cannot be generated again, and then asking the
solver whether the system of assertions is still satisfiable. If it is, a
second solution exists and the puzzle is considered invalid.

In such situations, the interactivity offered by \texttt{z3.rkt} becomes
useful: it lets the programmer add dynamically discovered constraints on the
fly. The last part of the solution might then become something like
\Fref{fig:sudoku-unique}.

\begin{program}
\caption{Ensuring that a Sudoku grid has exactly one solution}
\label{fig:sudoku-unique}
\begin{minted}{scheme}
   ...
   (if (eq? sat 'sat)
       ; Make sure no other solution exists
       (let ([result-grid
         (for/list ([x (in-range 0 81)])
           (smt:eval (select/s sudoku-grid x)))])
         ; Assert that we want a brand new solution by
         ; asserting (not <current solution>)
         (smt:assert
          (not/s (apply and/s
                   (for/list ([(x i) (in-indexed result-grid)])
                     (=/s (select/s sudoku-grid i) x)))))
         (if (eq? (smt:check-sat) 'sat)
             #f ; Multiple solutions
             result-grid))
       #f)))
\end{minted}
\end{program}

This part can even be abstracted out into a function that returns a
lazily-generated sequence of satisfying assignments for any given set of
constraints.

\subsection{Number Mind}

\hl{TOCHECK This section is brand new.}

The deductive game Bulls and Cows, commercialised as
Master~Mind~\cite{mastermind}, is popular all around the world. The rules may
vary slightly, but their essence stays the same: Two players play the game.
One player (we'll call her Alice) thinks of a 4-digit number, and the other
(Bob) tries to find it. Bob guesses a number, and Alice tells him how many
digits he has correct and in the correct position (\textit{bulls}) and how
many he has correct but in the wrong position (\textit{cows}).

The game is deceptively simple: while even the standard 4-digit variant is
challenging for humans, the general problem for $n$ digits is
NP-complete~\cite{mastermindnpc}. As such, it becomes an interesting problem for
constraint solvers.

For simplicity, we tackle a variant of the game:
Number~Mind~\cite{numbermind}, where Bob only tells Alice how many digits are
correct and in the correct place (bulls). The user is Alice and the computer
Bob, which means that the game is \textit{interactive}. An API to solve
Number~Mind would have

\begin{enumerate}[(a)]
\item a way to tell the computer how many digits the number has
\item a way for the computer to guess a number
\item a way for the user to tell the computer how many digits it got correct
  in the last guess.
\end{enumerate}

The constraint solver would have an important role in not just (a) and (c) but
also (b), since we would like the computer to make ``reasonable" guesses and
not just wild ones.

Our system makes all three tasks simple. \Fref{fig:numbermind} defines three
functions, each corresponding to one of the tasks above.

\begin{program}
\caption{Solving Number Mind using \texttt{z3.rkt}}
\label{fig:numbermind}
\begin{minted}{scheme}
; (a) Create variables for each digit
(define (make-variables num-digits)
  (define vars (smt:make-fun/list num-digits () Int))
  ; Every variable is between 0 and 9
  (for ([var vars]) (smt:assert (and/s (>=/s var 0) (<=/s var 9))))
  vars)

; (b) Guess a number. Returns the guess as a list of digits,
; or #f meaning no number can satisfy all the constraints.
(define (get-new-guess vars)
  (define sat (smt:check-sat))
  (if (eq? sat 'sat)
      ; Get a guess from the SMT solver
      (map smt:eval vars)
      #f))

; (c) How many digits the computer got correct. If a digit is correct
; then we assign it the value 1, otherwise 0. We sum up the values
; and assert that that's equal to the number of correct digits.
(define (add-guess vars guess correct-digits)
  (define correct-lhs
    (apply +/s
           (for/list ([x guess]
                      [var vars])
             (ite/s (=/s var x)
                    1      ; Correct guess
                    0))))  ; Wrong guess
  (smt:assert (=/s correct-lhs correct-digits)))
\end{minted}
\end{program}

As a demonstration of \texttt{z3.rkt}, we have written a small web application
around the above code. The web application is available at

\begin{center}
\url{http://numbermind.less-broken.com}
\end{center}

The source is also available:

\begin{center}
\url{https://github.com/sid0/numbermind}
\end{center}
